#summary New features in lambdaj 2.2

The following new features and improvements have been added with the release 2.2:

*1.* A method to *convert the values of a given Map through a lambdaj Converter* (suggested by Robert Blumen):

{{{
Map<K,W> convertMap(Map<K,V> map, Converter<V,W> converter)
}}}

allows to convert the values of the given Map by applying to each of them the conversion defined by the given converter.

*2.* A method that *count the occurencies of each object in an Iterable*:

{{{
Map<A,Integer> count(Iterable<A>)
}}}

returning a Map having as keys the objects in the Iterable and as values the Integers corresponding to the number of their occurrences.

*3.* Also the *object on which the closure is invoked can be an unbuond variable*.

By passing to the of() method a class instead of an object you're saying that the object on which the closure will be invoked will be passed during the closure invocation itself. For example if you define a closure as it follows:

{{{
Closure2<Person, Integer> ageSetter = closure(Person.class, Integer.class); {
    of(Person.class).setAge(var(Integer.class));
}
}}}

you can then invoke it in this way:

{{{
ageSetter.apply(person, 35);
}}}

*4.* The possibility to *define a closure also without using a ThreadLocal*.

Somebody found confusing (or code smell) to bound a closure to a ThreadLocal before to define it. Now you can create a closure without any ThreadLocal as it follows:

{{{
Closure2<Person, Integer> ageSetter = new Closure2<Person, Integer>() {{
    of(Person.class).setAge(var(Integer.class));
}};
}}}

*5.* The possibility to *define a closure on a final class or that invokes a static method*.

For example the following closure will cause to invoke the static method Integer.parseInt(String string):

{{{
Closure1<String> intParser = closure(String.class).of(Integer.class, "parseInt", var(String.class));
}}}
	
this one returns a substring of the string "mario" by calling the method substring(int start, int end)

{{{
Closure2<Integer, Integer> substringOfMyName = closure(Integer.class, Integer.class)
    .of("mario", "substring", var(Integer.class), var(Integer.class));
}}}

and this last one converts a given string in upper case:
		
{{{
Closure1<String> toUpperCase = closure(String.class).of(String.class, "toUpperCase");
}}}

The method to be invoked by the closure is defined by its name and not by registering the method invocation on the proxy returned by the of() method. Of course it is possible to define a closure in this way also when the invoked method is not static and doesn't belong to a final class, even if in this way the strong typed invocation is lost.

*6.* The possibility to *define a closure that invokes a constructor*.

By using the constant Closure.CONSTRUCTOR as method name in the closure definition form provided by the former point it is possible to define a closure that invokes a costructor. For example if you have a class Person with a constructor Person(String name, int age) you can define a closure that invokes it:

{{{
Closure2<String, Integer> personCreator = closure()
    .of(Person.class, Closure.CONSTRUCTOR, var(String.class), var(Integer.class));
}}}
		
and then create a Person by invoking apply() on this closure as it follows:

{{{		
Person me = (Person)personCreator.apply("Mario", 36);
}}}

*7.* A [http://lambdaj.googlecode.com/svn/trunk/html/apidocs/index.html Switcher] that greatly enriches the feature of the native java switch in order to provide a powerful and easy to read tool to implement strategy and factory patterns.

Through a fluent interface you can add cases to the Switcher that in the most general case can be defined with the method:

{{{
Switcher<T> addCase(Matcher<?> matcher, Closure closure);
}}}
	
When the Switcher is called if the object passed to it matches a given Matcher the corresponding closure is invoked. There are a couple of overload that allows to use any object instead of a Matcher (in this case an equalTo(object) Matcher is used, meaning that the case is activated when the switcher is invoked with an object equals to the one that defines the case) and/or any object instead of the closure (that will be the object returned by the Switcher when the corresponding case matches). For example it is possible to define a Switcher as it follows

{{{
Switcher<Integer> switcher = new Switcher<Integer>()
    .addCase("+", closure().of(this, "add", var(Integer.class), var(Integer.class)))
    .addCase("-", closure().of(this, "sub", var(Integer.class), var(Integer.class)))
    .addCase("*", closure().of(this, "mul", var(Integer.class), var(Integer.class)))
    .addCase("/", closure().of(this, "div", var(Integer.class), var(Integer.class)))
    .setDefault(0);
}}}
		
so when the Swicther is invoked the following value are returned.

{{{
int result = switcher.exec("+", 3, 2) // result == 5
int result = switcher.exec("*", 3, 2) // result == 6
int result = switcher.exec("?", 3, 2) // result == 0
}}}
	
The first argument of the exec() method is the one used to evaluate the switch while all the following ones (if any) are passed to the closure that corresponds to the matching case. It is also possible to set a default value that is returned when the first argument doesn't match any other case. Even the defualt value can be a fixed one or a closure. To give another example, having built the following Switcher:

{{{
Switcher<String> switcher = new Switcher<String>()
    .addCase(new Person("me", 36), "me")
    .addCase(having(on(Person.class).getAge(), lessThan(30)), "young")
    .addCase(having(on(Person.class).getAge(), greaterThan(70)), "old")
    .setDefault("adult");
}}}

you will obtain the following results while executing it:		

{{{		
String result = switcher.exec(new Person("me", 36)); // result == "me";
String result = switcher.exec(new Person("sister", 31)); // result == "adult";
String result = switcher.exec(new Person("dad", 71)); // result == "old";
}}}
		
Finally, by using closures that invoke constructor it is easy to say how it is possible to implement a factory pattern in a declarative way:

{{{
Switcher<Person> factory = new Switcher<Person>()
    .addCase("me", closure().of(Person.class, Closure.CONSTRUCTOR, "Mario", var(Integer.class)))
    .addCase("sis", closure().of(Person.class, Closure.CONSTRUCTOR, "Irma", var(Integer.class)))
    .addCase("dad", closure().of(Person.class, Closure.CONSTRUCTOR, "Domenico", var(Integer.class)));
}}}

so by calling:

{{{
Person sis = factory.exec("sis", 31);
}}}

you will obtain a Parson named Irma and aged 31. 